# Практическая работа 18. Оптимизация с помощью кеширования

  

# Практика 

## Видео 1. Что такое кеширование

- «[Что такое кеширование и как оно работает](https://aws.amazon.com/ru/caching/)»
    
- «[Что такое кэширование?](https://azure.microsoft.com/ru-ru/resources/cloud-computing-dictionary/what-is-caching/)»
    
- «[Кеш](https://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D1%88)»
    
- [Redis](https://redis.io/)
    
- [PostgreSQL](https://www.postgresql.org/)
    
- [Memcached](https://memcached.org/)
    
- [MongoDB](https://www.mongodb.com/)
    

## Видео 2. Система кеширования Django

- [Django’s cache framework](https://docs.djangoproject.com/en/4.2/topics/cache/)
    
- [Django’s per-site-cache](https://docs.djangoproject.com/en/4.2/topics/cache/#the-per-site-cache) 
    

## Видео 3. Кеширование представлений (view)

[Django’s cache framework. The per-view cache](https://docs.djangoproject.com/en/4.2/topics/cache/#the-per-view-cache) 

## Видео 4. Кеширование фрагмента шаблона

[Django’s cache framework. Template fragment caching](https://docs.djangoproject.com/en/4.2/topics/cache/#template-fragment-caching) 

## Видео 5. Использование низкоуровневого Cache API в Django

[Django’s cache framework. The low-level cache API](https://docs.djangoproject.com/en/4.2/topics/cache/#the-low-level-cache-api) 

  

# Цели практической работы

- Применить в проекте кеширование. 
    
- Научиться работать с кешированием в шаблонах и с низкоуровневым кешированием.
    

# Что нужно сделать

Воспользуйтесь кодовой базой из пройденных модулей или файлами из репозитория практической работы.

  

1. Реализуйте страницу со списком заказов пользователя. В адресной строке можно передать ID пользователя и посмотреть все его заказы. Если пользователь не найден, нужно вернуть ошибку 404. Адрес страницы должен быть защищён от анонимного доступа (можно пускать только зарегистрированных пользователей).
    

- Добавьте новое представление — view на основе функции или класса. Например, в приложении ShopApp создайте новый класс UserOrdersListView.
    
- Подключите новый view к urls. В пути укажите динамическую переменную для ID пользователя. Например: "users/<int:user_id>/orders/".
    
- Внутри view получите пользователя, ID которого передан в запросе. В class based views такие параметры доступны в словаре self.kwargs. В методе get_queryset добавьте фильтрацию по выбранному пользователю. Сохраните полученный объект пользователя на текущий экземпляр view-класса (например, через self.owner = ...), этот объект пригодится повторно.
    
- В методе get_context_data обновите контекст, добавьте информацию о выбранном пользователе.
    
- Обновите шаблон списка заказов. Отобразите в нём информацию о пользователе в формате «Пользователь (имя) выполнил следующие заказы» / «У пользователя (имя) ещё нет заказов».
    

3. Добавьте кеширование части шаблона, где отображается список заказов. Информацию о пользователе оставьте без кеширования.
    

- В шаблоне подключите тег cache.
    
- В теге укажите срок кеширования, ключ для кеша, уникальный ключ пользователя, заказы которого отображаются (это не текущий пользователь, в шаблоне переменная user уже занята текущим пользователем — используйте другое имя для передачи в контекст, например owner). Ключом пользователя может быть его идентификатор (PK/ID).
    
- Внутри тега cache должна быть информация о заказах.
    
- Кеш должен быть уникальным для каждого пользователя.
    

5. Создайте новое представление для экспорта данных о заказах выбранного пользователя. Идентификатор пользователя передавайте в адресной строке (в пути). Если пользователь не найден, верните ошибку 404. Данные о заказах верните в JSON-формате.
    

- Используйте view-класс или view-функцию для создания представления.
    
- Подключите новое представление к urls, например по адресу: "users/<int:user_id>/orders/export/".
    
- Внутри представления выполните запрос пользователя на основе идентификатора из пути запроса. Если пользователь не найден, верните ошибку 404.
    
- Загрузите все заказы пользователя. Примените сортировку по первичному ключу.
    
- Верните результат в JSON-формате. Используйте сериализатор для заказов, чтобы построить массив из объектов.
    

7. Добавьте кеширование сериализованных данных при помощи низкоуровневого API в Django. При повторном запросе экспорта заказов одного пользователя не должно возникать дополнительных запросов в базу в ближайшие несколько минут.
    

- Импортируйте cache из django.core.cache.
    
- Сгенерируйте ключ с учётом идентификатора пользователя, информацию о заказах которого нужно загрузить.
    
- Загрузите из кеша заготовленные данные, верните их в ответе.
    
- Если данные в кеше не были найдены, загрузите всю информацию (пользователь, его заказы) и сохраните результат в кеш.
    

# Что оценивается 

- Реализована страница со списком заказов пользователя. В адресной строке можно передать ID пользователя и посмотреть все его заказы. Если пользователь не найден, возвращается ошибка 404. Доступ к странице есть только у зарегистрированных пользователей. На странице отображается информация о пользователе и список всех его заказов.
    
- Часть шаблона, где отображается список заказов, обёрнута в кеш.
    

- Внутри тега cache — информация о заказах.
    
- Кеш уникален для каждого пользователя.
    

- Создано представление для экспорта данных о заказах выбранного пользователя. Идентификатор пользователя можно передать в адресной строке (в пути). Если пользователь не найден, возвращается ошибка 404. Данные о заказах возвращаются в JSON-формате.
    

- Загружаются только заказы выбранного пользователя (не авторизованного, а того, чей идентификатор указан в адресной строке).
    
- Список заказов отсортирован по первичному ключу.
    
- Использован сериализатор для заказов.
    

- Добавлено кеширование сериализованных данных при помощи низкоуровневого API в Django. При повторном запросе экспорта заказов одного пользователя не возникает дополнительных запросов в базу в ближайшие несколько минут.
    

- Использован cache из django.core.cache.
    
- Ключ для кеша генерируется с учётом идентификатора пользователя, информацию о заказах которого нужно загрузить. Кеш уникален для каждого пользователя (не авторизованного, а того, что выбран в адресной строке).
    
- Выполняется проверка данных в кеше. Если данные есть, они возвращаются без дополнительных запросов в базу.
    
- Если данные в кеше не найдены, информация загружается из базы, подготавливается и сохраняется в кеш.
    
- Использован сериализатор заказов.
    

# Как отправить работу на проверку

Выполните работу в Skillbox GitLab. В поле ниже напишите «Сделано» и прикрепите ссылку на репозиторий.
